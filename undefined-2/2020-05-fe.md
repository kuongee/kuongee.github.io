# 2020-05 카카오 FE 준비

### 비즈니스 서비스는 카카오 for 비즈니스, 챗봇 오픈 빌더, 챗봇 주문 서비스, 카카오톡의 공통 플러그인과 웹 분석 시스템을 만들고 운영하는 업무입니다. <a href="#docs-internal-guid-2a3c1bdf-7fff-7072-8e82-558d08ab7365" id="docs-internal-guid-2a3c1bdf-7fff-7072-8e82-558d08ab7365"></a>

### 자기 소개

사용자들에게 편의를 주고 도움이 되는 서비스를 개발하고 싶습니다. 책임감있고&#x20;

꾸준히 성장하는 개발자가 되려고 노력하고 있습니다.\


비즈니스 서비스는 사용자를 도움으로써 사용자의 비즈니스의 성장과 함께 서비스의 성장에도 기여 할 수 있다는 점에서 매력을 느껴 지원하게 되었습니다.

최근에는 브라우저를 통해 바로 바로 구현의 결과물을 확인하며 문제 해결에 집중할 수 있고 꼼꼼한 제 성격과도 잘 맞는 프론트엔드 개발에 흥미를 느끼고 있습니다.&#x20;

#### 대학원 때는 무엇을 했나

(지원한 직무와는 크게 관련이 없다고 생각하여 기술적인 내용은 적지 않았습니다. 하지만 대학원 과정을 거치며 끈기있게 문제를 해결하려고 하는 힘이 길러졌고 그것을 실무에서도 자신있게 적용할 수 있다고 생각합니다. 코드를 분석하고 디버깅하는 과정을 즐기려고 합니다.)

자원 관리를 통해 성능 향상하는 연구를 진행했습니다. 공통 자원을 사용하는 어플리케이션들의 성능 저하를 경험할 수 있기 때문에 최적의 격리된 자원 크기를 예측하여 제공하는 연구들이었습니다.

### 이직 사유

주도적으로 자체 서비스를 만들어나가는 서비스를 해보고 싶다.\


회사를 다니면서 개인의 성장과 함께 조직이 성장할 때 보람있는 일이라고 생각한다.

입사 이후 담당 업무와 프로젝트의 잦은 변화로 개발자로서 현업의 경험과 실력을 갖추기가 너무 어려웠음.

무엇보다 내가 책임감을 가지고 참여한 프로젝트를 단기간에  끝내는 것이 아쉬웠음.

(그렇다고 다른 사람들의 생각은 어떨지 모르겠으나 개인적으로는 조직의 성장도 체감하기는 어려웠음.)\


최근 참여한 프로젝트를 하면서 프론트엔드 개발에 대한 애정이 생겼고 성장하는 서비스 개발을 경험하고 싶었다.

### 참여 프로젝트 소개

* 파일 보안 관리 프로젝트의 Admin 시스템 프론트엔드 개발 담당
* 파일 보안 관리 프로젝트에 대해 간단히 소개하자면, 문서에 보존기간/보안정책을 설정하여 전사적으로 문서보안 이슈를 미연에 방지하는 것을 목표로 가지고 있다.
* Admin 시스템에서는 사용자 포탈의 히스토리 조회, 관리자 관리, 권한 관리 등과 정책 관리, 환경설정 등의 일을 합니다. Admin 시스템의 사용자는 시스템 관리자, 운영자 입니다.
* 사용자 포탈에서는 보존 기한 연장을 신청하거나 정책 예외 신청을 할 수가 있다.

여기서 신청하고 승인 받는 알림/메일이 오고 가는데 이 과정에 대한 히스토리를 어드민에서 확인할 수 있다.

* 저는 관리자 관리 페이지, 테넌트 관리 페이지 등의 구현을 담당했고 그 외 페이지들의 유지보수에도 참여했습니다.

#### 나는 이 프로젝트에서 무엇을 했나?

초기에는 컴포넌트들을 조합하여 페이지 구현에 집중했다. 페이지를 구현하면서 공통으로 사용할 수 있는 컴포넌트들을 따로 빼내고 팀원들과 공유했다.

어려웠던 점. 내가 구현한 컴포넌트를 팀원이 받아들일 수 있게 하는 것 왜 이거를 prop로 정의했고 props에 대한 설명

왜냐하면 내 나름대로 구현을 했는데 상대는 그게 왜 그렇게 동작하는지에 대한 설명이 필요

컨테이너는 어떻게 움직이는지를 담당한다\
프리젠터는 어떻게 보여지는지를 담당한다\
상태가 없는 프리젠터는 재활용 가능하다

* 목록 조회 테이블 상단에 아이템 총 갯수, 페이지 개수 조회 같은 거
* 컴포넌트 기능 강화 등

메뉴 관리는 어떻게?

사용자가 접근 가능한 메뉴 정보를 서버로부터 전달 받음. 메뉴 라우팅 정보, lnb 메뉴 목록을 필터링해서 그려줌\


### 스터디에서는 무엇을 했나?

프로젝트를 리액트로만 사용하다보니까 웹 프론트엔드의 기초를 놓치는 느낌이 들어서 시작하게 되었다. 바닐라 자바스크립트를 이용해 직접 구현하며 공부하는 스터디였다.\


### SPA란?&#x20;

Single Page Application

SPA는 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드한다. 이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있고, 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다.\


#### SPA에서 SEO 문제

전통적인 서버 사이드 렌더링 중심의 애플리케이션은 매 페이지가 완전히 독립되고 초기 렌더링 시 컨텐츠를 포함되는 경우가 많기 때문에 크롤링 시 별다른 문제가 생기지 않는다.

하지만 SPA에선 초기 렌더링 시 얻는 HTML가 실제 컨텐츠를 포함한 HTML이 아닌 경우가 많기 때문에 SEO에서 문제가 생긴다.

https://rotodevspace.wordpress.com/2015/02/23/single-page-application에서-검색엔진-최적화-적용하기/\


그에 앞서 구글이 SPA를 검색하는 단계를 정리해보면, 구글 크롤러는,

1. URL에 해쉬 기호와 느낌표(!)가 들어가 있는지 체크한다. ( i.g. http://example.com/#!/posts/1 )
2. 해쉬뱅(Hashbang, #!) 부분을 “\_escaped\_fragment\_=” 문자로 대체한다. ( i.g. http://example.com/?\_escaped\_fragment=/posts/1 )
3. 2번에서 대체시킨 새로운 URL로 서버에 다시 요청을 보낸다.
4. 요청에 대한 응답으로 받은 컨텐츠를 대상으로 검색 작업을 수행한다.

출처: https://funnygangstar.tistory.com/entry/싱글-페이지-어플리케이션에서의-검색-엔진-최적화-SEO \[eXtreme Code]

### React

* UI를 component 단위로 쪼개서 만들어낼 수 있게 하는 라이브러리
  * 시시때때로 변하는 데이터를 잘 보여주자
  * 생성한 UI Component의 재사용성을 높이자
* React의 장점은 수시로 변하는 데이터들을 렌더링할 때 더 커짐
  * 기존의 JavaScript app에서는 데이터의 변화를 감지하고 DOM에 변화를 적용해주어야 함
* 이렇게 한다.

1. component는 render method를 통해 그려짐
2. 데이터가 변하면 render method가 다시 불림
3. 변한 부분을 효율적으로 그려주기 위해 react는 이전에 render된 것과 현재 render된 부분과의 차이를 이용해 DOM에 가장 최소한의 변화만을 적용하게 됨

* 이 과정을 reconciliation 이라고 함
  * [https://reactjs.org/docs/reconciliation.html](https://reactjs.org/docs/reconciliation.html)
  * [https://meetup.toast.com/posts/110](https://meetup.toast.com/posts/110)
  * [https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e](https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e)
* Re-render 과정이 빠르기도 하지만 Data binding을 지정해줄 필요가 없음(무슨 말인지 비교해보기)
  * Data Binding
    * 분리된 View와 Model을 하나로 연결하는 것
    * Angular의 경우 DOM에 직접 접근하지 않고 템플릿과 컴포넌트 클래스의 상호 관계를 선언하는 방식으로 View와 Model 관계를 관리
    * 기존 웹 애플리케이션은 자바스크립트 DOM API가 DOM을 직접 조작하는 방식
* React는 단방향 데이터 흐름 (one-way data flow)

#### 이 프로젝트에서 어떻게 React를 사용했나

atomic 디자인으로 컴포넌트를 나누었다.

크게 페이지 단위로 나누었고 페이지 단위로 작업했다.\


#### 이 프로젝트에서 왜 React를 사용했을까?

개발 팀원들의 리액트에 대한 선호도가 상당히 높았고 이미 한번씩 경험이 있는 상황이었다.

그래서 대세에 따라가기는 했는데 React를 사용하면서 React가 사용하기 좋았다고 느낀 경우가 있었는데 개인적으로는 리액트를 다른 라이브러리나 프레임워크보다 먼저 사용하고 익숙해져있는 상태라 Vue와 같이 템플릿과 메소드가 나눠져있는 형태는 어색했다.\


#### 리액트를 사용해서 좋았던 점이나 편리했던 점

템플릿과 메소드를 한데 모아서 보기가 좋았다.

컴포넌트 단위로 나누어 개발하는 것의 편리함을 느낄 수 있었다.

#### React 렌더링 되는 시점

props 변경, state 변경, forceUpdate, 부모렌더링 → 자식렌더링

#### Router

#### React의 Life cycle

마운트

아래 메서드들은 컴포넌트의 인스턴스가 생성되어 DOM 상에 삽입될 때에 순서대로 호출

* constructor()
* static getDerivedStateFromProps()
* render()
* componentDidMount()

업데이트

props 또는 state가 변경되면 갱신이 발생 / 아래 메서드들은 컴포넌트가 다시 렌더링될 때 순서대로 호출

* static getDerivedStateFromProps()
* shouldComponentUpdate()
* render()
* getSnapshotBeforeUpdate()
* componentDidUpdate()

마운트 해제

아래 메서드는 컴포넌트가 DOM 상에서 제거될 때에 호출

* componentWillUnmount()

#### Redux 사용해보았나요? Redux란?

리덕스는 글로벌하게 상태 관리를 할 수 있게 해준다. 컴포넌트 외부에서.

부모 → 자식 이동되는 데이터가 흐르는 구조에서 여러 컴포넌트를 거쳐 상태를 받아오지 않아도 됨

* subscribe : 스토어 구독, 상태 변경되면 알려줘
* dispatch : 상태 변화가 생겼을 때 액션을 전달해서 스토어에 상태 변경하라고 알려줌
* 리듀서: 업데이트 로직을 정의하는 함수를 리듀서라고 부릅니다
* listener: 상태 변화가 생기면 구독하고 있던 컴포넌트에게 알림

어떻게 상태관리를 할까?

1. 스토어 생성
2. 스토어에 원하는 데이터 있는 쪽에서 Subscribe!
3. 어떤 컴포넌트에서 변화가 생겨서 스토어로 Dispatch!&#x20;
4. 스토어에서는 action을 전달받아서 리듀서 함수에 따라 상태를 업데이트
   1. 리듀서 함수는 action, 현재 state 전달받음
5. 등록한 리스너 함수가 호출됨

[https://velopert.com/3533](https://velopert.com/3533)\


#### FLCM에서는 어떻게 Redux를 사용했는지

전역 상태 관리를 위해 redux를 사용한다

1. user event에 해당하는 action을 생성
2. store.dispatch()를 통해 action을 전달
3. store는 reducer에 action을 전달
4. reducer는 action에 맞게 변경된 상태를 생성하여 store에게 반환
5. store는 상태를 변경
6. 화면 업데이트

Redux State

실제 사용하는 상태 관리는 아래 부분으로 확인된다.

* 세션 상태
* 로딩 표시 상태
* 에러 팝업 표시 상태
* alert/confirm 팝업 표시 상태

#### 내가 추가한 거

테넌트 생성으로 LNB 테넌트 목록 드롭다운 테넌트 목록 업데이트

TenantMange.jsx

```
const mapDispatchToProps = dispatch => ({
    loadTenantsOption() {
        dispatch(loadTenants.loadTenantsOption());
    }
});
export default injectIntl(connect(null, mapDispatchToProps)(TenantManage));

TenantsDropdown.jsx
const mapStateToProps = state => ({
    loadTenantsOption: state.loadTenants.loadTenantsOption
});
const mapDispatchToProps = dispatch => ({
    doneLoadTenantsOption() {
        dispatch(loadTenants.doneTenantsOption());
    }
});
export default connect(mapStateToProps, mapDispatchToProps)(TenantsDropdown);

src\redux\actions\loadTenants.js
export const LOAD_TENANTS = 'LOAD_TENANTS';
export const DONE_TENANTS = 'DONE_TENANTS';
function action(type, payload = {}) {
    return { type, ...payload };
}
export const loadTenantsOption = () => action(LOAD_TENANTS);
export const doneTenantsOption = () => action(DONE_TENANTS);

src\redux\reducers\loadTenants.js
import * as ActionTypes from '../actions/loadTenants';
const defaultState = {
    loadTenantsOption: false
};
const loadTenants = (state = {}, action = {}) => {
    switch (action.type) {
        case ActionTypes.LOAD TENANTS: {
            return Object.assign({}, defaultState, state, { loadTenantsOption: true });
        }
        case ActionTypes.DONE_TENANTS: {
            return Object.assign({}, defaultState, state, { loadTenantsOption: false });
        }
        default:
            return state;
    }
};
export default loadTenants;
```



하위 컴포넌트의 전역 상태 사용/변경

\<Provider />의 하위 컴포넌트들을 전역 상태 사용하고 변경할 수 있다

하위 컴포넌트에서는 connect HOC를 통하여, 전역 상태와 dispatch()를 props로 전달받아 사용할 수 있다

#### Hooks

함수형 컴포넌트에 라이프사이클을 사용할 수 있음

### 쿠키 세션

### 브라우저에서 URL 입력하면 어떻게 되나?

### Javascript

#### 클로저

[https://vallista.kr/2019/05/11/%ED%81%B4%EB%A1%9C%EC%A0%80-Closure/](https://vallista.kr/2019/05/11/%ED%81%B4%EB%A1%9C%EC%A0%80-Closure/)

[https://medium.com/@Dongmin\_Jang/javascript-closure-hoisting-7bf8eb5062b9](https://medium.com/@Dongmin\_Jang/javascript-closure-hoisting-7bf8eb5062b9)

[https://poiemaweb.com/js-closure](https://poiemaweb.com/js-closure)\
\


let const var + 호이스팅

[https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d](https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d)\


#### 호이스팅

[https://junhobaik.github.io/js-let-cont-hoisting/](https://junhobaik.github.io/js-let-cont-hoisting/)\


#### ES6

* es5와의 차이
* var / let, const
* Arrow function

#### 프로토타입

자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 Prototype(프로토타입)이라 한다.

Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 공유 프로퍼티를 제공하기 위해 사용한다.

#### this

함수 호출 방식에 따라 바인딩 되는 객체가 달라진다.\


#### 함수

[https://programmer-seva.tistory.com/25](https://programmer-seva.tistory.com/25)\


#### 세션 스토리지, 로컬 스토리지

CORS

로컬 테스트에서의 주의 사항 — HTML파일을 로컬(예를들어 file:// URL)에서 로드하려고 하면, 자바스크립트 모듈 보안 요구 사항으로 인해 CORS오류가 발생합니다. 서버를 통해 테스트 해야 합니다.\


#### rest parameter, spread

https://poiemaweb.com/es6-extended-parameter-handling\
\


Axios\


### CSS

#### position

* static : 기본값
* relative: 아무것도 설정 안 하면 static과 동일하게 동작. 상대 위치가 지정된 엘리먼트에 top이나 right, bottom, left를 지정하면 기본 위치와 다르게 위치가 조정됩니다. 다른 콘텐츠는 해당 엘리먼트에서 남긴 공백에 맞춰 들어가게끔 조정되지 않을 것입니다.
* fixed: 고정(fixed) 엘리먼트는 뷰포트(viewport)에 상대적으로 위치가 지정되는데, 이는 페이지가 스크롤되더라도 늘 같은 곳에 위치한다는 뜻입니다. relative와 마찬가지로 top이나 right, bottom, left 프로퍼티가 사용됩니다.
  * 뷰포트: 사용자에게 보여지는 영역. 스크롤 해도 보여지는 영역
* absolute: absolute는 가장 다루기 까다로운 위치 지정 값입니다. absolute는 뷰포트에 상대적으로 위치가 지정되는 게 아니라 가장 가까운 곳에 위치한 조상 엘리먼트에 상대적으로 위치가 지정된다는 점을 제외하면 fixed와 비슷하게 동작합니다. 절대 위치가 지정된 엘리먼트가 기준으로 삼는 조상 엘리먼트가 없으면 문서 본문(document body)을 기준으로 삼고, 페이지 스크롤에 따라 움직입니다. "위치가 지정된" 엘리먼트는 position이 static으로 지정되지 않은 엘리먼트를 가리킨다는 사실을 기억하세요.

#### transform

CSS 변형(transform)은 좌표공간을 변형함으로써 일반적인 문서 흐름을 방해하지 않고 콘텐츠의 형태와 위치를 바꿉니다. 본 가이드는 변형 사용법의 기초를 제시합니다.

CSS 변형은 HTML 요소에 선형 아핀 변형(affine linear transformation)을 적용하는 여러 개의 CSS 속성을 조합해 구현합니다. 변형은 평면과 3D 공간에서의 회전, 확대, 이동, 비틀기를 포함합니다.

| <p>#abs-element {</p><p>  position: absolute;</p><p>  left: 50%;</p><p>  transform: translateX(-50%);</p><p>}</p> |
| ----------------------------------------------------------------------------------------------------------------- |

참 쉽죠? left 혹은 right 속성은 부모의 width를 기준으로 길이를 잡습다만, transform은 자기 자신의 width를 기준으로 길이를 정합니다. 그 결과 요소는 왼쪽을 기준으로 부모 요소 width의 50% 만큼 이동한뒤, 자기 자신의 width의 50% 만큼을 왼쪽으로 땡깁니다.\
\
\


탭별로 라우팅

```
import TeamCstd from './teamCstd/TeamCstd';
import UserCstd from './userCstd/UserCstd';
import UnrealTeamCstd from './unrealTeamCstd/UnrealTeamCstd';

// eslint-disable-next-line react/prefer-stateless-function
class RetentionPeriod extends Component {
    onClickTab = index => {
        const { match, history } = this.props;
        switch (index) {
            case 0:
                history.push(`${match.url}/policy`);
                break;
            case 1:
                history.push(`${match.url}/dept`);
                break;
            case 2:
                history.push(`${match.url}/unreal-dept`);
                break;
            case 3:
                history.push(`${match.url}/user`);
                break;
            default:
                history.push(`${match.url}`);
                break;
        }
    };

    render() {
        const { match, routeConfig, intl } = this.props;

        const items = [
            {
                label: intl.formatMessage({ id: 'admin.tab.retention.period.policyRegister' }),
                content: <PolicyCstd routeConfig={routeConfig} guideMessage={intl.formatMessage({ id: 'admin.guideText.retention.period.policy' })} />
            },
            {
                label: intl.formatMessage({ id: 'admin.tab.retention.period.policyApply.dept' }),
                content: <TeamCstd routeConfig={routeConfig} guideMessage={intl.formatMessage({ id: 'admin.guideText.retention.period.dept' })} />
            },
            {
                label: intl.formatMessage({ id: 'admin.tab.retention.period.policyApply.unreal-dept' }),
                content: (
                    <UnrealTeamCstd
                        routeConfig={routeConfig}
                        guideMessage={intl.formatMessage({ id: 'admin.text.retention.unreal-dept.guid-massage' })}
                    />
                )
            },
            {
                label: intl.formatMessage({ id: 'admin.tab.retention.period.policyApply.user' }),
                content: <UserCstd routeConfig={routeConfig} guideMessage={intl.formatMessage({ id: 'admin.guideText.retention.period.user' })} />
            }
        ];

        const renderTabPanel = currentIndex => {
            return (
                <>
                    <TabGroup>
                        {items.map(({ label }, index) => {
                            return (
                                // eslint-disable-next-line react/no-array-index-key
                                <Tab key={index} onClickTab={this.onClickTab} isActive={index === currentIndex}>
                                    {label}
                                </Tab>
                            );
                        })}
                    </TabGroup>
                    <Panel key={currentIndex} active={true}>
                        {items[currentIndex].content}
                    </Panel>
                </>
            );
        };

        return (
            <>
                <Tabs>
                    <Switch>
                        {/* 정책 등록 탭 */}
                        <Route exact path={`${match.url}/policy`} render={() => renderTabPanel(0)} />
                        {/* 정책 적용 (부서) 탭 */}
                        <Route exact path={`${match.url}/dept`} render={() => renderTabPanel(1)} />
                        {/* 정책 적용 (가상 부서) 탭 */}
                        <Route exact path={`${match.url}/unreal-dept`} render={() => renderTabPanel(2)} />
                        {/* 정책 적용 (사용자) 탭 */}
                        <Route exact path={`${match.url}/user`} render={() => renderTabPanel(3)} />
                        {/* default: 정책 등록 탭 */}
                        <Redirect push={true} to={`${match.url}/policy`} />
                    </Switch>
                </Tabs>
            </>
        );
    }
}

export default withDialog(injectIntl(RetentionPeriod));

RetentionPeriod.propTypes = {
    routeConfig: PropTypes.object.isRequired,
    match: PropTypes.object.isRequired,
    history: PropTypes.object.isRequired
};
```

\-------------------------------------------------------------------------------------------------------\
\


보존기한 정책

보존기한 설정, 검사대상 유형(어떤 확장자인지)

부서, 사용자에 어떤 정책을 적용할 것인지\


NonCp&#x20;

이 정책을 부서, 사용자에게 적용할것인지 말것인지\


테넌트 생성 관리

이 시스템을 쓸 테넌트(회사) 관리\


관리자 계정 / 역할

어드민 시스템 쓸 수 있는 계정 관리

계정이 접근할 수 있는 역할들 정의\


![](https://lh6.googleusercontent.com/V4QrLhlohQkDB5M2EOhRiLX7SyEMKTylOYsJv9OGIQuDbhZKZmgTl6mBiVbRlQytHT2DIuZEfx8Jtf-sRMuRNwBwbsrIY6sUwJ9Vej-EM3-Q5qhH3gw3EpS7eVH1LozuSU7u55s\_)

admin은 다시 보니까 이걸로 정리되네

\- 업무 운영

1\. 유저 포탈에서 무슨 일을 했는지에 대한 로그 정리

2\. 사용자 별 권한 주기

3\. 메일 뭐뭐 보냈는지 확인

\-정책 관리

1\. 보존기한 정책 관련 설정 변경

2\. Non-compliance 정책 설정

\- 테넌트 관리

1\. 환경 설정

\-시스템 관리, 관리자 제어

1\. 테넌트 생성 및 관리자별 권한주기

\------------------

파일 만료 / 기간 연장 알림 메일, / CPGS 알림,  예외 요청 메일

CPGS 예를 들면 담합, 선투입 등등\


나스카 클라이언트에서 정책 수신\
만료 일자 설정 파일 업로드시 보존기간 설정/조회\
CPGS 문서 업로드시 검출\
KNox drive 보존기간 메일링 배치\
knox drive 삭제 배치\
KNOX 드라이브 기간 연장 요청\
FLCM 기간 연장 승인\


유저포탈은 해당 파일의 상위 관리자

해당 파일의 직책 상위자\


어드민은 해당 시스템 전체 관리자

\-----------------------------------------------------------------------------------------------------------\


정책등록

이름

어느 기간동안 어떤 파일 확장자에 대해서 이 정책을 적용할건지

회사별 부서별 적용 가능해서 \


현황 조회

메일 발신, 요청

정책 등록 -> 적용

적용 여부

검사대상유형

임직원 문서보안 향상\


여러 솔루션이 있고 flcm은 어떤 정책이 적용되어있는지 확인하는 용도 어떤 정책이 적용되어있니? 이런 거\


유저

파일 만료 기간연장 조회 서비스/ 파일 만료 승인 반려 서비스

CPGS 예외 신청 서비스

사용자 관리\
\


테이블 위에 있는 Total, 목록 갯수 보기

File Life Cycle Management\


어드민 (운영자, 정책 관리자 등)

테넌트 생성/관리

* 보존기간,cpgs 적용 여부
* 연계 서비스 설정

보존기간

* 보관기간 등급 설정
* 부서/사용자 보관등급 설정
* 목록노출 설정: 만료 N일 전
* 유예기간 설정: 만료 N일 후
* 사전 알림: N일 전 파일, M일 주기 알림

CPGS

* 금칙어 조건 설정
* 부서/사용자 정책 적용 설정
* 유예기간: N일 설정
* 사전 알림: N일 전 파일, M일 주기 알림
* TextWithLength
* 멀티 select가 가능한 dropdown
* checked / unchecked
* 선택한 value 갯수와 option의 갯수 비교
* 탭 url로 나누기

Pages 의 route exact =false\
\


\-----------------------------------------------------------------------------------------------------------
