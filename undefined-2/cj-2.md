# CJ올리브영 2차 준비

자기소개

## 1차 면접 내용 보완

### SPA

* SPA는 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드한다. 이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있고, 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다.
* 장점
  * 페이지의 필요한 부분만 업데이트하기때문에 **트래픽이 적고** 페이지 **이동이 그만큼 빨라집니다**.
  * 최초접속시 필요한 모든 정적 리소스들을 다운받고 이미 방문한 페이지도 캐싱합니다.
  * CSR 의 특징을 이용해서 페이지 화면전환 애니메이션을 넣어서 **사용자 친화적**으로 만들 수 있습니다.
  * 모듈화나 컴포넌트화를 통해 **유지보수를 쉽게** 만들고 **개발 속도를 빠르게** 만들어줍니다.
  * 프론트와 백엔드의 분리로 **개발업무 분업화**가 쉽습니다.
* 단점
  * 리소스를 초기에 다 다운받기 때문에 **초기 구동속도**가 느립니다.
  * html 렌더링을 클라이언트에서 하기 때문에 **검색엔진최적화(SEO)**가 어렵습니다.

https://www.youtube.com/watch?v=PN\_WmsgbQCo

### Virtual DOM

https://www.youtube.com/watch?v=sJ14cWjrNis



## 1차 때 답 못했던 질문들

#### HTTP vs HTTPS

* [https://joshua1988.github.io/web-development/http-part1/](https://joshua1988.github.io/web-development/http-part1/)
*   ‘HTTP vs HTTPS 차이’는 바로 SSL 인증서입니다. 사실 HTTPS는 쉽게 말해서 HTTP 프로토콜에 보안 기능을 추가한 것이라고 말할 수 있는데요. 보안 기능은 생각보다 매우 중요합니다. 특히 신용카드 정보나 비밀번호 등 사용자들의 민감한 정보들을 다루는 웹사이트에서라면 더욱 그렇죠.

    **SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화하는데, 쉽게 말해서 데이터를 암호로 바꾼다고 생각하면 쉽습니다. 이렇게 전송된 데이터는 중간에서 누군가 훔쳐 낸다고 하더라도 데이터가 암호화되어있기 때문에 해독할 수 없습니다. 그 외에도 HTTPS는 TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지합니다.** TSL은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공하고 있습니다.
* [https://jeong-pro.tistory.com/89](https://jeong-pro.tistory.com/89)
* http://blog.wishket.com/http-vs-https-차이-알면-사이트의-레벨이-보인다/
* **HTTPS의 암호화의 전송을 이해하는데 필요한 개념들**
  * 1\. 암호화: 어떤 정보를 암호화된 정보로 바꾸는 것이며,\
    &#x20;2\. 복호화: 암호화된 정보를 다시 원래 정보로 바꾸는 것입니다.\
    &#x20;3\. 키: 암호화, 복호화할 때 쓰는 비밀번호이며,\
    &#x20;4\. HTTPS는 공통 키 방식과 비대칭 키 방식을 같이 사용합니다.
  *   **공통 키 방식: 암호화할 때와 복호화할 때 같은 키를 사용하는 방식입니다.**

      &#x20;1\. 장점: 단순한 구조로 CPU를 적게 쓰고 빠르다.\
      &#x20;2\. 단점: 공통 키를 빼앗기면 복호화를 할 수 있으므로 보안에 취약하다는 단점이 있다.
  *   **비대칭 키 방식: 암호화할 때와 복호화할 때 다른 키를 사용하는 비대칭 방식입니다.**

      &#x20;1\. 클라이언트는 공통 키를, 서버는 인증서와 공개 키를 제공하며 클라이언트는 서버가 제공한 공개 키를 통해 공통 키를 암호화하여 서버에게 전송합니다. 서버는 수신한 HTTPS의 인증서와 공개 키 일치를 바탕으로 공통 키를 복호해 요청에 대응합니다.\
      &#x20;2\. 장점: 키 전송과정 중 빼앗겨도(해킹 당해도) 빼앗은 자(해커)가 해독을 할 수 없으니 공통 키 방식보다 보다 안전합니다.\
      &#x20;3\. 단점: 공통 키 방식보다 느리고 리소스 소비가 큽니다.

#### HTTP1.0 vs HTTPS2.0

*

![](<../.gitbook/assets/image (33).png>)

HTTP는 TCP

HTTP1.0 connection 하나에 요청 하나 -> 성능 저하

HOL 은 요청이 순서대로&#x20;

HTTP2&#x20;

[https://goldfishhead.tistory.com/26](https://goldfishhead.tistory.com/26)

#### promise 공부하고 있다고 함 -> **어떤 API...???** 있냐고 물어보심 (잘 몰라서 그냥 아무거나 대답함)

* [https://ko.javascript.info/promise-api](https://ko.javascript.info/promise-api)
*   `Promise` 클래스에는 5가지 정적 메서드가 있습니다.

    1. `Promise.all(promises)` – 모든 프라미스가 이행될 때까지 기다렸다가 그 결괏값을 담은 배열을 반환합니다. 주어진 프라미스 중 하나라도 실패하면 `Promise.all`는 거부되고, 나머지 프라미스의 결과는 무시됩니다.
    2. `Promise.allSettled(promises)` – 최근에 추가된 메서드로 모든 프라미스가 처리될 때까지 기다렸다가 그 결과(객체)를 담은 배열을 반환합니다. 객체엔 다음과 같은 정보가 담깁니다.
       * `status`: `"fulfilled"` 또는 `"rejected"`
       * `value`(프라미스가 성공한 경우) 또는 `reason`(프라미스가 실패한 경우)
    3. `Promise.race(promises)` – 가장 먼저 처리된 프라미스의 결과 또는 에러를 담은 프라미스를 반환합니다.
    4. `Promise.resolve(value)` – 주어진 값을 사용해 이행 상태의 프라미스를 만듭니다.
    5. `Promise.reject(error)` – 주어진 에러를 사용해 거부 상태의 프라미스를 만듭니다.

    실무에선 다섯 메서드 중 `Promise.all`을 가장 많이 사용합니다.
* 프라미스 메서드 `Promise.resolve`와 `Promise.reject`는 `async/await` 문법([뒤에서](https://ko.javascript.info/async-await) 다룸)이 생긴 후로 쓸모없어졌기 때문에 근래에는 거의 사용하지 않습니다.

vue-i18n이 뭔지? 어떻게 사용했는지

* ko.json, en.json 파일을 각각 만들어서 vue-i18n에서 사용할 수 있도록&#x20;
* locale은 어디서
  * 처음 진입하면 기본으로 로컬스토리지에 저장되어있다.

